(self.webpackChunk_brick_hooks_root=self.webpackChunk_brick_hooks_root||[]).push([[5275],{73602:function(h,r,t){"use strict";t.d(r,{m:function(){return l.m}});var l=t(67624),p=t(93142)},55481:function(h,r,t){"use strict";t.r(r),t.d(r,{default:function(){return U}});var l=t(75290),p=t(67294),f=JSON.parse('{"menus":{"en-US":{"*":[{"path":"/","title":"brick-hooks","meta":{}}],"/create-context-hook":[{"path":"/create-context-hook","title":"createContextHook","meta":{}}],"/use-array":[{"path":"/use-array","title":"useArray","meta":{}}],"/use-async":[{"path":"/use-async","title":"useAsync","meta":{}}],"/use-countdown":[{"path":"/use-countdown","title":"useCountDown","meta":{}}],"/use-counter":[{"path":"/use-counter","title":"useCounter","meta":{}}],"/use-countup":[{"path":"/use-countup","title":"useCountUp","meta":{}}],"/use-data-list-to-map":[{"path":"/use-data-list-to-map","title":"useDataListToMap","meta":{}}],"/use-data-list-to-tree":[{"path":"/use-data-list-to-tree","title":"useDataListToTree","meta":{}}],"/use-data-tree-to-list":[{"path":"/use-data-tree-to-list","title":"useDataTreeToList","meta":{}}],"/use-debounce-effect":[{"path":"/use-debounce-effect","title":"useDebounceEffect","meta":{}}],"/use-debounce-fn":[{"path":"/use-debounce-fn","title":"useDebounceFn","meta":{}}],"/use-debounce-state":[{"path":"/use-debounce-state","title":"useDebounceState","meta":{}}],"/use-debounce-value":[{"path":"/use-debounce-value","title":"useDebounceValue","meta":{}}],"/use-deep-compare":[{"path":"/use-deep-compare","title":"useDeepCompare","meta":{}}],"/use-did-mount":[{"path":"/use-did-mount","title":"useDidMount","meta":{}}],"/use-did-update":[{"path":"/use-did-update","title":"useDidUpdate","meta":{}}],"/use-effect-maunal":[{"path":"/use-effect-maunal","title":"useEffectMaunal","meta":{}}],"/use-event-bus":[{"path":"/use-event-bus","title":"useEventBus","meta":{}}],"/use-force-render":[{"path":"/use-force-render","title":"useForceRender","meta":{}}],"/use-history-ref":[{"path":"/use-history-ref","title":"useHistoryRef","meta":{}}],"/use-history-state":[{"path":"/use-history-state","title":"useHistoryState","meta":{}}],"/use-input":[{"path":"/use-input","title":"useInput","meta":{}}],"/use-interval":[{"path":"/use-interval","title":"useInterval","meta":{}}],"/use-iso-effect":[{"path":"/use-iso-effect","title":"useIsoEffect","meta":{}}],"/use-list-checked":[{"path":"/use-list-checked","title":"useListChecked","meta":{}}],"/use-list-data":[{"path":"/use-list-data","title":"useListData","meta":{}}],"/use-list-sequence-load":[{"path":"/use-list-sequence-load","title":"useListSequenceLoad","meta":{}}],"/use-list-state":[{"path":"/use-list-state","title":"useListState","meta":{}}],"/use-list-view-data":[{"path":"/use-list-view-data","title":"useListViewData","meta":{}}],"/use-log-render":[{"path":"/use-log-render","title":"useLogRender","meta":{}}],"/use-memo-compare":[{"path":"/use-memo-compare","title":"useMemoCompare","meta":{}}],"/use-methods":[{"path":"/use-methods","title":"useMethods","meta":{}}],"/use-methods-immer":[{"path":"/use-methods-immer","title":"useMethodsImmer","meta":{}}],"/use-object-state":[{"path":"/use-object-state","title":"useObjectState","meta":{}}],"/use-object-state-immer":[{"path":"/use-object-state-immer","title":"useObjectStateImmer","meta":{}}],"/use-previous":[{"path":"/use-previous","title":"usePrevious","meta":{}}],"/use-reducer-immer":[{"path":"/use-reducer-immer","title":"useReducerImmer","meta":{}}],"/use-ref-callback":[{"path":"/use-ref-callback","title":"useRefCallback","meta":{}}],"/use-render-count":[{"path":"/use-render-count","title":"useRenderCount","meta":{}}],"/use-set":[{"path":"/use-set","title":"useSet","meta":{}}],"/use-throttle-fn":[{"path":"/use-throttle-fn","title":"useThrottleFn","meta":{}}],"/use-timeout":[{"path":"/use-timeout","title":"useTimeout","meta":{}}],"/use-timeout-fn":[{"path":"/use-timeout-fn","title":"useTimeoutFn","meta":{}}],"/use-toggle":[{"path":"/use-toggle","title":"useToggle","meta":{}}],"/use-trim":[{"path":"/use-trim","title":"useTrim","meta":{}}],"/use-trim-state":[{"path":"/use-trim-state","title":"useTrimValue","meta":{}}],"/use-unmounted-ref":[{"path":"/use-unmounted-ref","title":"useUnmountedRef","meta":{}}],"/use-value-ref":[{"path":"/use-value-ref","title":"useUpdateRef","meta":{}}],"/use-will-unmount":[{"path":"/use-will-unmount","title":"useDidMount","meta":{}}],"/use-animate":[{"path":"/use-animate","title":"useAnimate","meta":{}}],"/use-breakpoint":[{"path":"/use-breakpoint","title":"useBreakpoint","meta":{}}],"/use-cookie":[{"path":"/use-cookie","title":"useCookie","meta":{}}],"/use-dark-mode":[{"path":"/use-dark-mode","title":"useDarkMode","meta":{}}],"/use-event-listener":[{"path":"/use-event-listener","title":"useEventListener","meta":{}}],"/use-free-drag":[{"path":"/use-free-drag","title":"useFreeDrag","meta":{}}],"/use-hover":[{"path":"/use-hover","title":"useHover","meta":{}}],"/use-in-view":[{"path":"/use-in-view","title":"useInView","meta":{}}],"/use-key":[{"path":"/use-key","title":"useKey","meta":{}}],"/use-lazy-image":[{"path":"/use-lazy-image","title":"useLazyImage","meta":{}}],"/use-lazy-sequence-load":[{"path":"/use-lazy-sequence-load","title":"useLazySequenceLoad","meta":{}}],"/use-link":[{"path":"/use-link","title":"useLink","meta":{}}],"/use-media":[{"path":"/use-media","title":"useMedia","meta":{}}],"/use-media-query":[{"path":"/use-media-query","title":"useMediaquery","meta":{}}],"/use-online":[{"path":"/use-online","title":"useOnline","meta":{}}],"/use-script":[{"path":"/use-script","title":"useScript","meta":{}}],"/use-scroll":[{"path":"/use-scroll","title":"useScroll","meta":{}}],"/use-scroll-fixed":[{"path":"/use-scroll-fixed","title":"useFixed","meta":{}}],"/use-storage":[{"path":"/use-storage","title":"useStorage","meta":{}}],"/use-style":[{"path":"/use-style","title":"useStyle","meta":{}}],"/use-title":[{"path":"/use-title","title":"useTitle","meta":{}}],"/use-transition":[{"path":"/use-transition","title":"useTransition","meta":{}}],"/native":[{"title":"UseAnimate","path":"/native/use-animate","meta":{},"children":[{"path":"/native/use-animate","title":"useAnimate","meta":{}}]},{"title":"UseAnimateValue","path":"/native/use-animate-value","meta":{},"children":[{"path":"/native/use-animate-value","title":"useAnimateValue","meta":{}}]},{"title":"UseAppstate","path":"/native/use-appstate","meta":{},"children":[{"path":"/native/use-appstate","title":"useAppState","meta":{}}]},{"title":"UseAsyncStorage","path":"/native/use-async-storage","meta":{},"children":[{"path":"/native/use-async-storage","title":"useAsyncStorage","meta":{}}]},{"title":"UseFocusApp","path":"/native/use-focus-app","meta":{},"children":[{"path":"/native/use-focus-app","title":"useFocusApp","meta":{}}]},{"title":"UseInView","path":"/native/use-in-view","meta":{},"children":[{"path":"/native/use-in-view","title":"useInView","meta":{}}]},{"title":"UseLazySequenceLoad","path":"/native/use-lazy-sequence-load","meta":{},"children":[{"path":"/native/use-lazy-sequence-load","title":"useLazySequenceLoad","meta":{}}]},{"title":"UseScrollToTop","path":"/native/use-scroll-to-top","meta":{},"children":[{"path":"/native/use-scroll-to-top","title":"useScrollToTop","meta":{}}]},{"title":"UseTransition","path":"/native/use-transition","meta":{},"children":[{"path":"/native/use-transition","title":"useTransition","meta":{}}]}],"/business":[{"title":"UseAmapPoi","path":"/business/use-amap-poi","meta":{},"children":[{"path":"/business/use-amap-poi","title":"useAmapPoi","meta":{}}]}],"/use-cascader":[{"path":"/use-cascader","title":"useCascader","meta":{}}],"/use-cycle-buy":[{"path":"/use-cycle-buy","title":"useCycleBuy","meta":{}}],"/":[{"title":"\u4ECB\u7ECD","path":"/"},{"title":"Brick-hooks","children":[{"path":"/create-context-hook","title":"createContextHook"},{"path":"/use-array","title":"useArray"},{"path":"/use-async","title":"useAsync"},{"path":"/use-counter","title":"useCounter"},{"path":"/use-debounce-effect","title":"useDebounceEffect"},{"path":"/use-debounce-fn","title":"useDebounceFn"},{"path":"/use-debounce-state","title":"useDebounceState"},{"path":"/use-debounce-value","title":"useDebounceValue"},{"path":"/use-deep-compare","title":"useDeepCompare"},{"path":"/use-did-mount","title":"useDidMount"},{"path":"/use-will-unmount","title":"useDidMount"},{"path":"/use-did-update","title":"useDidUpdate"},{"path":"/use-unmounted-ref","title":"useUnmountedRef"},{"path":"/use-effect-maunal","title":"useEffectMaunal"},{"path":"/use-iso-effect","title":"useIsoEffect"},{"path":"/use-event-bus","title":"useEventBus"},{"path":"/use-force-render","title":"useForceRender"},{"path":"/use-input","title":"useInput"},{"path":"/use-interval","title":"useInterval"},{"path":"/use-memo-compare","title":"useMemoCompare"},{"path":"/use-methods","title":"useMethods"},{"path":"/use-methods-immer","title":"useMethodsImmer"},{"path":"/use-object-state","title":"useObjectState"},{"path":"/use-object-state-immer","title":"useObjectStateImmer"},{"path":"/use-previous","title":"usePrevious"},{"path":"/use-reducer-immer","title":"useReducerImmer"},{"path":"/use-ref-callback","title":"useRefCallback"},{"path":"/use-value-ref","title":"useUpdateRef"},{"path":"/use-set","title":"useSet"},{"path":"/use-throttle-fn","title":"useThrottleFn"},{"path":"/use-list-checked","title":"useListChecked"},{"path":"/use-list-data","title":"useListData"},{"path":"/use-list-state","title":"useListState"},{"path":"/use-list-view-data","title":"useListViewData"},{"path":"/use-data-list-to-tree","title":"useDataListToTree"},{"path":"/use-data-list-to-map","title":"useDataListToMap"},{"path":"/use-data-tree-to-list","title":"useDataTreeToList"},{"path":"/use-list-sequence-load","title":"useListSequenceLoad"},{"path":"/use-log-render","title":"useLogRender"},{"path":"/use-render-count","title":"useRenderCount"},{"path":"/use-timeout","title":"useTimeout"},{"path":"/use-timeout-fn","title":"useTimeoutFn"},{"path":"/use-toggle","title":"useToggle"},{"path":"/use-trim-state","title":"useTrimValue"},{"path":"/use-trim","title":"useTrim"},{"path":"/use-countdown","title":"useCountDown"},{"path":"/use-countup","title":"useCountUp"},{"path":"/use-history-ref","title":"useHistoryRef"},{"path":"/use-history-state","title":"useHistoryState"}]},{"title":"Brick-hooks-web","children":[{"path":"/use-animate","title":"useAnimate"},{"path":"/use-breakpoint","title":"useBreakpoint"},{"path":"/use-cookie","title":"useCookie"},{"path":"/use-dark-mode","title":"useDarkMode"},{"path":"/use-event-listener","title":"useEventListener"},{"path":"/use-free-drag","title":"useFreeDrag"},{"path":"/use-hover","title":"useHover"},{"path":"/use-in-view","title":"useInView"},{"path":"/use-key","title":"useKey"},{"path":"/use-lazy-image","title":"useLazyImage"},{"path":"/use-lazy-sequence-load","title":"useLazySequenceLoad"},{"path":"/use-link","title":"useLink"},{"path":"/use-media","title":"useMedia"},{"path":"/use-media-query","title":"useMediaquery"},{"path":"/use-online","title":"useOnline"},{"path":"/use-script","title":"useScript"},{"path":"/use-scroll","title":"useScroll"},{"path":"/use-scroll-fixed","title":"useFixed"},{"path":"/use-storage","title":"useStorage"},{"path":"/use-style","title":"useStyle"},{"path":"/use-title","title":"useTitle"},{"path":"/use-transition","title":"useTransition"}]},{"title":"Brick-hooks-native","path":"/native","children":[{"path":"/native/use-animate","title":"useAnimate"},{"path":"/native/use-animate-value","title":"useAnimateValue"},{"path":"/native/use-transition","title":"useTransition"},{"path":"/native/use-appstate","title":"useAppstate"},{"path":"/native/use-async-storage","title":"useAsyncStorage"},{"path":"/native/use-focus-app","title":"useFocusApp"},{"path":"/native/use-in-view","title":"useInView"},{"path":"/native/use-lazy-sequence-load","title":"useAnimate"},{"path":"/native/use-scroll-to-top","title":"useScrollToTop"}]},{"title":"Brick-hooks-business","children":[{"path":"/business/use-amap-poi","title":"useAmapPoi"},{"path":"/use-cascader","title":"useCascader"},{"path":"/use-cycle-buy","title":"useCycleBuy"}]}]}},"locales":[{"name":"en-US","label":"English"}],"navs":{"en-US":[{"title":"\u6307\u5357","path":"/"},{"title":"\u66F4\u65B0\u65E5\u5FD7","path":"https://github.com/MingNeo/custom-hooks/releases"},{"title":"GitHub","path":"https://github.com/MingNeo/custom-hooks"}]},"title":"Brick-hooks","logo":"/logo.svg","mode":"site","repository":{"url":"https://github.com/MingNeo/custom-hooks","branch":"master"},"theme":{},"exportStatic":{}}'),a=t(6840),y=t(6500),s=t.n(y),u=t(79004),g=`import React from 'react'
import useCountDown from '.'

export const Demo1 = () => {
  const { formatedCountdown } = useCountDown({ endTime: Date.now() + 1000000, step: 1000 })

  return (
    <div>
      <p>\u8BBE\u7F6E\u6307\u5B9A\u65F6\u95F4\u5012\u8BA1\u65F6</p>
      <p>{formatedCountdown}S</p>
    </div>
  )
}

export const Demo2 = () => {
  const { formatedCountdown, start } = useCountDown({ total: 5000, format: 's.SS', step: 10, autoRun: false })

  return (
    <div>
      <button onClick={start}>\u6BCF\u6B215\u79D2\u5012\u8BA1\u65F6</button>
      <p>{formatedCountdown}S</p>
    </div>
  )
}

export default function Demo() {
  return (
    <div>
      <Demo1 />
      <Demo2 />
    </div>
  )
}`,v=`import { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import {
  formatTime as formatTimeByString,
  isBrowser,
  getTimeByString,
  getformatTimeInfo,
  invariant,
  setIntervalBySetTimeout,
  clearTimer,
} from '../utils'

interface CountDownOptions {
  total?: number // \u5012\u8BA1\u65F6\u65F6\u95F4\uFF0C\u683C\u5F0F\u6BEB\u79D2
  endTime?: number | string // \u7ED3\u675F\u65F6\u95F4\uFF0C\u65F6\u95F4\u6233\u683C\u5F0F \u6216 "yyyy-mm-dd HH:MM:SS"
  format?: string | ((progress: number) => string) // \u5C55\u793A\u7684\u683C\u5F0F
  step?: number // \u5FAA\u73AF\u7684\u65F6\u95F4
  onStart?: () => void
  onStep?: (step: number, formatedProgress: string) => void
  onFinished?: () => void
  autoRun?: boolean
}

interface StateProps {
  endTime: number // \u7ED3\u675F\u65F6\u95F4
  countdown: number // \u5012\u8BA1\u65F6\u65F6\u95F4timestamp
  status: 'idle' | 'running' | 'pause' | 'resumed' | 'finished'
}

export default function useCountDown({
  onStart,
  onStep,
  onFinished,
  step,
  format = 'hh:mm:ss',
  endTime,
  total,
  autoRun = true,
}: CountDownOptions) {
  invariant(!!endTime || !!total, 'endTime and total need least one')
  invariant(!endTime || !total, 'endTime and total need only one')
  const intervalRef = useRef<number | null>(null)
  const timerRef = useRef<any>(null)
  const statusRef = useRef<string>('idle')
  const endTimeRef = useRef(
    typeof endTime === 'string' ? getTimeByString(endTime) : endTime || Date.now() + (total || 0),
  )
  const [{ endTime: endTimeState, status, countdown }, setState] = useState<StateProps>({
    status: 'idle',
    endTime: endTimeRef.current,
    countdown: 0,
  })

  const formatedCountdown = useMemo(() => formatTime(countdown, format), [countdown, format])

  // \u505C\u6B62\u5012\u8BA1\u65F6
  const stop = useCallback(() => {
    clearTimer(intervalRef.current)
    clearTimeout(timerRef.current)
    setState((prev) => ({ ...prev, countdown: 0, status: 'finished' }))
    statusRef.current = 'finished'
    onFinished?.()
  }, [onFinished, setState])

  // \u5F00\u59CB\u5012\u8BA1\u65F6
  const start = useCallback(() => {
    clearTimer(intervalRef.current)
    onStart?.()
    endTimeRef.current = !endTime ? Date.now() + (total || 0) : endTimeRef.current
    setState((prev) => ({ ...prev, status: 'running', endTime: endTimeRef.current }))
    statusRef.current = 'running'

    const running = () => {
      // \u6BCF\u6B21\u90FD\u53D6\u5F53\u524D\u65F6\u95F4\u6BD4\u8F83\uFF0C\u800C\u975E\u51CF\u53BBstep\u7684\u65F6\u95F4\uFF0C\u9632\u6B62\u8FDB\u5165\u540E\u53F0\u7B49\u9020\u6210\u4E0D\u51C6\u786E\u7684\u60C5\u51B5
      const currentCountDown = Math.max(endTimeRef.current - Date.now(), 0)
      const formatedProgress = formatTime(currentCountDown, format)

      setState((prev) => ({ ...prev, countdown: currentCountDown }))
      onStep?.(currentCountDown, formatedProgress)

      currentCountDown === 0 && stop()
      return currentCountDown
    }

    const raf =
      window.requestAnimationFrame ||
      (window as any).webkitRequestAnimationFrame ||
      ((callback: TimerHandler) => setTimeout(callback, 1000 / 60))
    const isUseInterval = (step && step >= 17) || !isBrowser

    timerRef.current = setTimeout(() => {
      const loop = () => {
        clearTimer(intervalRef.current)
        clearTimeout(timerRef.current)
        const progress = running()
        console.log('\u{1F680} ~ file: index.ts ~ line 85 ~ loop ~ progress', progress, statusRef.current)
        if (progress > 0 && statusRef.current === 'running') {
          intervalRef.current = isUseInterval ? setIntervalBySetTimeout(running, step) : raf(loop)
        }
      }
      loop()
    }, 0)
  }, [endTime, format, onStart, onStep, step, stop, total])

  useEffect(() => {
    autoRun && start()

    return () => {
      clearTimer(intervalRef.current)
      timerRef.current && clearTimeout(timerRef.current)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  return {
    status,
    endTime: endTimeState,
    formatedCountdown,
    countdown,
    ...getformatTimeInfo(countdown),
    start,
    stop,
  }
}

function formatTime(timestamp: number, format: string | ((progress: number) => string)) {
  // eslint-disable-next-line no-nested-ternary
  return typeof format === 'string'
    ? formatTimeByString(timestamp, format)
    : typeof format === 'function'
    ? format(timestamp)
    : ''
}`,m=`export function invariant(condition: boolean, message: string) {
  if (!condition) {
    throw new Error(message)
  }
}

export function isNil(value: any) {
  return value === undefined || value === null
}

export function isObject(value: any) {
  return typeof value === 'object' && Object.prototype.toString.call(value) === '[object Object]'
}

export function chunkArray(array, size = 1) {
  const length = array?.length || 0
  if (!length || size < 1) {
    return []
  }

  let index = 0
  const result = []

  while (index < length) {
    result.push(array.slice(index, (index += size)))
  }
  return result
}

export const isBrowser = !!(typeof window !== 'undefined' && window.document && window.document.createElement)

export const formatTime = (timestamp: number, format = 'dd hh:mm:ss.SSS'): string => {
  let formatedStr = format
  const dateFormat: any = {
    'd+': Math.floor(timestamp / 1000 / 60 / 60 / 24), // \u5929
    'h+': Math.floor((timestamp / 1000 / 60 / 60) % 24), // \u65F6
    'm+': Math.floor((timestamp / 1000 / 60) % 60), // \u5206
    's+': Math.floor((timestamp / 1000) % 60), // \u79D2
    'S+': timestamp % 1000,
  }

  Object.entries(dateFormat).forEach(([key, value]) => {
    const reg = new RegExp(\`(\${key})\`)
    if (reg.test(formatedStr))
      formatedStr = formatedStr.replace(reg, (m) => {
        if (key === 'S+') {
          return \`\${value}\${new Array(m.length).join('0')}\`.slice(0, m.length)
        }
        return m.length === 1 ? \`\${value}\` : \`00\${value}\`.substring(\`\${value}\`.length)
      })
  })
  return formatedStr
}

export const getformatTimeInfo = (timestamp: number) => {
  return {
    day: Math.floor(timestamp / 1000 / 60 / 60 / 24), // \u5929
    hour: Math.floor((timestamp / 1000 / 60 / 60) % 24), // \u65F6
    minutes: Math.floor((timestamp / 1000 / 60) % 60), // \u5206
    seconds: Math.floor((timestamp / 1000) % 60), // \u79D2
    millisecond: timestamp % 1000,
  }
}

const TIME_FORMAT_REG = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/

export const getDateByString = (date: string, utc = false) => {
  if (typeof date === 'string' && !/Z$/i.test(date)) {
    const d = date.match(TIME_FORMAT_REG) as any[]

    if (d) {
      const m = d[2] - 1 || 0
      const ms = (d[7] || '0').substring(0, 3)

      if (utc) {
        return new Date(Date.UTC(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms))
      }

      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms)
    }
  }

  return new Date(date)
}

export const getTimeByString = (date: string, utc = false) => getDateByString(date, utc).getTime()

/**
 * isFunction
 */
export function isFunction(value) {
  return typeof value === 'function'
}

export function setIntervalBySetTimeout(callback: () => void, delay: number) {
  let timer: ReturnType<typeof setTimeout> | null = null
  let offset = 0 // \u8BEF\u5DEE\u65F6\u95F4

  let count = 0
  let nextDelay = delay
  const start = Date.now()

  const loop = () => {
    nextDelay = delay - offset
    callback()
    timer = setTimeout(() => {
      offset = Date.now() - start - count * delay
      count++
      loop()
    }, nextDelay)
  }

  loop()
  return timer
}

export function clearTimer(timer: number) {
  if (!timer) return

  try {
    clearInterval(timer)
  } catch (error) {}

  try {
    const clearRaf = window.cancelAnimationFrame || (window as any).webkitCancelAnimationFrame
    clearRaf(timer)
  } catch (error) {}

  try {
    clearTimeout(timer)
  } catch (error) {}
}`,w=`import React from 'react'
import useCountUp from '.'

export const Demo1 = () => {
  const { formatedCountup } = useCountUp({ maxLength: 1000 * 60 * 10, format: 'dd hh:mm:ss' })

  return (
    <div>
      <p>\u8BA1\u65F610\u5206\u949F</p>
      <p>{formatedCountup}</p>
    </div>
  )
}

export const Demo2 = () => {
  const { formatedCountup, start } = useCountUp({ maxLength: 5000, format: 's.SS', step: 10, autoRun: false })

  return (
    <div>
      <button onClick={start}>\u6BCF\u6B215\u79D2\u8BA1\u65F6</button>
      <p>{formatedCountup}S</p>
    </div>
  )
}

export default function Demo() {
  return (
    <div>
      <Demo1 />
      <Demo2 />
    </div>
  )
}`,S=`import { useCallback, useEffect, useRef } from 'react'
import useForceRender from '../useForceRender'
import { formatTime as formatTimeByString, isBrowser, setIntervalBySetTimeout, clearTimer } from '../utils'

interface CountupProps {
  format?: string | ((progress: number) => string) // \u5C55\u793A\u7684\u683C\u5F0F
  step?: number // \u5FAA\u73AF\u7684\u65F6\u95F4
  onStart?: () => void
  onStep?: (countup: number, formatedCountup: string) => void
  onFinished?: (countup: number, formatedCountup: string) => void
  autoRun?: boolean
  maxLength?: number // \u6700\u957F\u65F6\u95F4,\u683C\u5F0F\u6BEB\u79D2,\u8D85\u8FC7\u65F6\u6839\u636EloopWhenEnd\u8FDB\u884C\u91CD\u7F6E\u6216\u505C\u6B62\u8BA1\u65F6
  loopWhenEnd?: boolean // \u662F\u5426\u5FAA\u73AF\u8BA1\u65F6\uFF0C\u503C\u4E3Atrue\u65F6\u8BA1\u65F6\u7ED3\u675F\u65F6\u81EA\u52A8\u4ECE0\u91CD\u65B0\u5F00\u59CB\u8BA1\u65F6, \u5426\u5219\u505C\u6B62
}

type Running = () => { countup: number; formatedCountup: string }

interface StateProps {
  status: 'idle' | 'running' | 'pause' | 'finished'
}

/**
 * \u8BA1\u65F6hooks\uFF0C\u53EF\u4EE5\u7528\u4E8E\u5929\u3001\u65F6\u3001\u5206\u3001\u79D2\u3001\u6BEB\u79D2\u7684\u8BA1\u65F6
 */
export default function useCountup({
  onStart,
  onStep,
  onFinished,
  step,
  format = 'dd hh:mm:ss.SSS',
  maxLength,
  autoRun = true,
  loopWhenEnd = false,
}: CountupProps) {
  const intervalRef = useRef<number | null>(null)
  const timerRef = useRef<number | null>(null)
  const statusRef = useRef<string>('idle')
  const runningListRef = useRef<Running[]>([])
  const countUpRef = useRef<number>(0)

  const forceUpdate = useForceRender()

  const setCountup = useCallback((value, shouldForceUpdate = false) => {
    countUpRef.current = value
    shouldForceUpdate && forceUpdate()
  }, [])

  const formatedCountup = formatTime(countUpRef.current, format)

  // \u505C\u6B62\u8BA1\u65F6
  const stop = useCallback(
    (reset = false) => {
      clearTimer(intervalRef.current)
      clearTimeout(timerRef.current)
      statusRef.current = 'finished'
      onFinished && onFinished(countUpRef.current, formatTime(countUpRef.current, format))
      runningListRef.current = []
      setCountup(reset ? 0 : countUpRef.current, true)
    },
    [onFinished, format]
  )

  // \u91CD\u7F6E\u8BA1\u65F6
  const reset = useCallback(() => {
    clearTimer(intervalRef.current)
    clearTimeout(timerRef.current)
    statusRef.current = 'idle'
    runningListRef.current = []
    setCountup(0, true)
  }, [])

  const getCurrentCountup = useCallback(
    (startTime) => {
      // \u6BCF\u6B21\u90FD\u53D6\u5F53\u524D\u65F6\u95F4\u6BD4\u8F83\uFF0C\u800C\u975E\u51CF\u53BBstep\u7684\u65F6\u95F4\uFF0C\u9632\u6B62\u8FDB\u5165\u540E\u53F0\u7B49\u9020\u6210\u4E0D\u51C6\u786E\u7684\u60C5\u51B5
      let currentCountup = Math.max(Date.now() - startTime, 0)
      const isOvertime = maxLength && currentCountup >= maxLength
      if (isOvertime) {
        if (loopWhenEnd) {
          currentCountup = 0
          startTime = Date.now()
        } else {
          currentCountup = maxLength
        }
      }
      const formatedProgress = formatTime(currentCountup, format)

      setCountup(currentCountup, true)
      onStep && onStep(currentCountup, formatedProgress)

      // \u8D85\u65F6\u5E76\u4E14\u4E0D\u5FAA\u73AF\u7684\u8BDD\u505C\u6B62\u8BA1\u65F6
      isOvertime && !loopWhenEnd && stop()
      return { countup: currentCountup, formatedCountup: formatedProgress }
    },
    [maxLength, loopWhenEnd, onStep, format]
  )

  // \u5F00\u59CB\u8BA1\u65F6
  const start = useCallback(() => {
    onStart && onStart()
    let startTime = Date.now()
    const running = () => getCurrentCountup(startTime)

    const raf = isBrowser ? window.requestAnimationFrame || (window as any).webkitRequestAnimationFrame : undefined
    // \u5982\u679C\u4E0D\u8BA1\u6BEB\u79D2\u3001\u6216\u8005\u6307\u5B9A\u6B65\u957F\u8D85\u8FC71/60\u79D2\u3001\u6216\u5728\u975E\u6D4F\u89C8\u5668\u7AEF\uFF0C\u5219\u4F7F\u7528setTimeout
    const isUseInterval = !raf || (step && step >= 17) || (typeof format === 'string' && !/S+/gi.test(format))

    timerRef.current = setTimeout(() => {
      statusRef.current = 'running'
      runningListRef.current.push(running)
      const loop = () => {
        clearTimer(intervalRef.current)
        clearTimeout(timerRef.current)
        // const progress = running()
        // \u7EF4\u62A4\u4E00\u4E2Arunning\u51FD\u6570\u6570\u7EC4\uFF0C\u7528\u4E8E\u6682\u505C\u548C\u6062\u590D
        const current = runningListRef.current.splice(0, 1)[0]
        const progress = current?.()
        if ((loopWhenEnd || progress.countup > 0) && statusRef.current === 'running') {
          runningListRef.current.push(running)
          intervalRef.current = isUseInterval ? setIntervalBySetTimeout(running, step) : raf(loop)
        }
      }
      loop()
    }, 0)
  }, [format, onStart, step, loopWhenEnd, getCurrentCountup])

  useEffect(() => {
    autoRun && start()

    return () => {
      clearTimer(intervalRef.current)
      timerRef.current && clearTimeout(timerRef.current)
    }
  }, [])

  return {
    status: statusRef.current,
    formatedCountup,
    countup: countUpRef.current,
    start,
    stop,
    reset,
    getCurrentCountup,
  }
}

function formatTime(timestamp: number, format: string | ((progress: number) => string)) {
  // eslint-disable-next-line no-nested-ternary
  return typeof format === 'string'
    ? formatTimeByString(timestamp, format)
    : typeof format === 'function'
    ? format(timestamp)
    : ''
}`,d=`import { useReducer } from 'react'

type ForceUpdate = () => void

/**
 * \u8FD4\u56DE\u4E00\u4E2AforceUpdate\u65B9\u6CD5\uFF0C\u6BCF\u6B21\u8C03\u7528\u89E6\u53D1\u51FD\u6570\u7EC4\u4EF6\u5F3A\u5236\u66F4\u65B0
 */
export default function useForceRender(): ForceUpdate {
  return useReducer((n: number) => n + 1, 0)[1]
}`,b=`import React, { useEffect } from 'react'
import useCounter from '../useCounter'
import useHistoryRef from '.'
import useForceRender from '../useForceRender'

export function Demo({ max = 10 } = {}) {
  const [count, { inc }] = useCounter(0)
  const forceUpdate = useForceRender()
  const { undo, redo, push, last, undoList, redoList, history } = useHistoryRef({
    max,
    onUpdate: (nextState) => {
      forceUpdate()
    },
  })

  useEffect(() => {
    push(count)
  }, [count, push])

  return (
    <div>
      <p>inputValue: {count}</p>
      <button onClick={(e) => inc()}>inc</button>
      <button disabled={undoList.length < 1} onClick={undo}>
        undo {undoList.length}
      </button>
      <button disabled={redoList.length < 1} onClick={redo}>
        redo
      </button>
      <p>last: {JSON.stringify(last)}</p>
      <p>undoList: {JSON.stringify(undoList)}</p>
      <p>history: {JSON.stringify(history)}</p>
      <p>redoList: {JSON.stringify(redoList)}</p>
    </div>
  )
}`,P=`import { useMemo, useState } from 'react'

interface CounterOptions {
  min?: number
  max?: number
  step?: number
}

interface Methods {
  set: (nextValue: number | ((value: number) => number)) => void
  inc: (step?: number) => void
  dec: (step?: number) => void
  reset: () => void
}

/**
 * \u8FD4\u56DE\u4E00\u4E2A\u6B65\u8FDB\u7684\u6570\u503C\uFF0C\u5E76\u63D0\u4F9B\u4E00\u7CFB\u5217\u65B9\u6CD5
 */
export default function useCounter(initialValue: number = 0, options: CounterOptions = {}): [number, Methods] {
  const [counter, setCounter] = useState(initialValue)

  const methods = useMemo(() => {
    const { min = -Infinity, max = Infinity, step: defaultStep = 1 } = options
    const setValue = (nextValue: number | ((value: number) => number)) => {
      const disposeValue = (value: number) => (value < min ? min : value > max ? max : value)
      setCounter((value) => disposeValue(typeof nextValue === 'function' ? nextValue(value) : nextValue))
    }
    return {
      set: setValue,
      inc: (step: number = defaultStep) => setValue((value: number) => value + step),
      dec: (step: number = defaultStep) => setValue((value: number) => value - step),
      reset: () => setCounter(initialValue),
    }
  }, [initialValue, options])

  return [counter, methods]
}`,R=`import { useRef } from 'react'
import HistoryState, { Options, HistoryStock } from './historyState'

export interface useHistoryRefOptions<Raw, Serialized = Raw> extends Options<Raw, Serialized> {}

export interface Return<Raw, Serialized> {
  source: Raw // \u539F\u59CB\u6570\u636E
  history: HistoryStock<Serialized>[] // \u5386\u53F2\u8BB0\u5F55\u5217\u8868
  last: HistoryStock<Serialized> // \u6700\u540E\u4E00\u6761\u5386\u53F2\u8BB0\u5F55
  undoList: HistoryStock<Serialized>[] // \u5386\u53F2\u8BB0\u5F55\u5217\u8868\uFF0C\u540Chistory
  redoList: HistoryStock<Serialized>[] // \u91CD\u505A\u7684\u5386\u53F2\u8BB0\u5F55\u5217\u8868
  canUndo: boolean // \u662F\u5426\u53EF\u4EE5\u64A4\u9500
  canRedo: boolean // \u662F\u5426\u53EF\u4EE5\u91CD\u505A
  undo(): void // \u64A4\u9500
  redo(): void // \u91CD\u505A
  clear(): void // \u6E05\u7A7A\u5386\u53F2\u8BB0\u5F55
  push(newSource: Raw): void // \u521B\u5EFA\u4E00\u6761\u65B0\u5386\u53F2
  reset(): void // \u91CD\u7F6E\u5230\u6700\u8FD1\u7684\u8BB0\u5F55
  getHistory: HistoryStock<any>[]
  getUndoList: HistoryStock<any>[]
  getRedoList: HistoryStock<any>[]
}

/**
 *
 * @param source
 * @param options
 * @returns
 */
export default function useHistoryRef<Raw, Serialized = Raw>(
  // source: Raw,
  options: useHistoryRefOptions<Raw, Serialized> = {}
): Return<Raw, Serialized> {
  const ref = useRef<any>()
  if (!ref.current) {
    ref.current = new HistoryState(options)
  }

  return ref.current
}`,C=`export interface HistoryStock<T> {
  snapshot: T
  timestamp: number
}

export interface Options<Raw, Serialized = Raw> {
  max?: number // \u6700\u591A\u4FDD\u5B58\u591A\u5C11\u6761\u6570\u636E\uFF0C\u9ED8\u8BA4\u4E0D\u9650\u5236
  dump?: (source: Raw) => Serialized // \u5E8F\u5217\u5316\u6570\u636E\u7684\u51FD\u6570
  parse?: <Raw, Serialized = Raw>(value: Serialized) => Raw // \u53CD\u5E8F\u5217\u5316\u6570\u636E\u7684\u51FD\u6570
  onUpdate?: (value: Raw, dump: HistoryStock<Serialized>) => void // \u66F4\u65B0\u6570\u636E\u7684\u56DE\u8C03
}

function defaultDump<R, S>(source: R): S {
  if (typeof source === 'object' || Array.isArray(source)) {
    return JSON.parse(JSON.stringify(source)) as S
  }
  return source as unknown as S
}

function defaultParse<Raw, Serialized = Raw>(sourceDump: Serialized) {
  try {
    return JSON.parse(sourceDump as unknown as string) as Raw
  } catch (error) {
    return sourceDump as unknown as Raw
  }
}

export default class HistoryState<Raw, Serialized = Raw> {
  source: any
  last: HistoryStock<any> = {
    snapshot: undefined,
    timestamp: 0,
  }

  undoList: HistoryStock<any>[] = []
  redoList: HistoryStock<any>[] = []
  max: number
  dump: (v: Raw) => Serialized
  parse: <Raw, Serialized = Raw>(sourceDump: Serialized) => Raw
  onUpdate: (value: Raw, dump: HistoryStock<Serialized>) => void

  constructor(options: Options<Raw, Serialized> = {}) {
    const { max, dump = defaultDump, parse = defaultParse, onUpdate = (nextState: Raw) => {} } = options
    this.dump = dump
    this.parse = parse
    this.onUpdate = onUpdate
    this.push = this.push.bind(this)
    this.undo = this.undo.bind(this)
    this.redo = this.redo.bind(this)
    this.clear = this.clear.bind(this)
    this.reset = this.reset.bind(this)
    this.max = max
  }

  get canUndo() {
    return this.undoList.length > 0
  }

  get canRedo() {
    return this.redoList.length > 0
  }

  get history() {
    return this.undoList
  }

  createHistoryItem(newSource: Raw) {
    const newHistoryItem = {
      snapshot: this.dump(newSource),
      timestamp: Date.now(),
    }
    return newHistoryItem
  }

  undo() {
    if (this.canUndo) {
      const state = this.undoList.shift()
      if (state && this.last) {
        this.redoList.unshift(this.last)
        this._changeState(state)
      }
    }
  }

  redo() {
    if (this.canRedo) {
      const state = this.redoList.shift()
      this.undoList.unshift(this.last)
      this._changeState(state)
    }
  }

  clear() {
    this.undoList = []
    this.redoList = []
    this.onUpdate(this.source, this.last)
  }

  push(newSource: Raw) {
    const isFirst = typeof this.source === 'undefined'
    this.source = newSource
    if (isFirst) {
      this.undoList = []
      this.redoList = []
      const next = this.createHistoryItem(newSource)
      this.last = next
      this.onUpdate(this.source, this.last)
    } else if (this.last && this.last.snapshot !== this.undoList?.[0]?.snapshot) {
      this.undoList.unshift(this.last)
      if (this.max && this.undoList.length > this.max) this.undoList.splice(this.max, Infinity)
      if (this.redoList.length) this.redoList.splice(0, this.redoList.length)
      this.last = this.createHistoryItem(this.source)
      this._changeState(this.last)
    }
  }

  reset() {
    this._changeState(this.last)
  }

  private _changeState(record: HistoryStock<Serialized>) {
    const next = this.parse(record.snapshot) as unknown as Raw
    this.source = next
    this.last = record
    this.onUpdate(next, record)
  }

  getHistory() {
    return this.history
  }

  getUndoList() {
    return this.undoList
  }

  getRedoList() {
    return this.redoList
  }

  getCanUndo() {
    return this.canUndo
  }

  getCanRedo() {
    return this.canRedo
  }

  getSource() {
    return this.source
  }

  getLast() {
    return this.last
  }
}`,T=`import React, { useEffect } from 'react'
import useAmapPoi from '.'

export default function Demo() {
  const { currentPoi, pois, nearbyPois, onSelectPoi, setCurrentPos, getNearbyPois, searchPois } = useAmapPoi({
    amapKey: 'e2a0790d42bc5bfdebceb30b2b71f349',
  })

  useEffect(() => {
    setCurrentPos({ latitude: '36.062687', longitude: '120.384599' })
  }, [])

  console.log('\u{1F680} ~ file: demo.tsx ~ line 8 ~ Demo ~ pois', pois)

  return (
    <div>
      <div>{currentPoi?.city}</div>
      <div style={{ display: 'flex' }}>
        <ul>
          {pois?.map((v, i) => (
            <li key={i}>{v.name}</li>
          ))}
        </ul>
        <ul>
          {nearbyPois?.map((v) => (
            <li
              key={v.id}
              style={{ background: currentPoi?.name === v.name ? 'blue' : 'white' }}
              onClick={() => onSelectPoi(v)}
            >
              {v.name}
            </li>
          ))}
        </ul>
      </div>

      <button onClick={() => searchPois({ city: '\u9752\u5C9B', address: '\u4E94\u56DB\u5E7F\u573A' })}>\u641C\u7D22\u4E94\u56DB\u5E7F\u573A</button>
      <button onClick={() => getNearbyPois({ current: { latitude: '36.062687', longitude: '120.384599' } })}>
        \u83B7\u53D6\u4E94\u56DB\u5E7F\u573A\u9644\u8FD1
      </button>
    </div>
  )
}`,L=`import { useState, useRef } from 'react'
import { isBrowser } from '../utils'
import { formatPoiInfo, getNearByInfos, loadAmapScript, searchPois } from './helper'

type Location = {
  latitude?: string
  longitude?: string
  [x: string]: any
}

type Poi = {
  latitude?: string
  longitude?: string
  [x: string]: any
}

interface AmapNearByPoiInfo extends Poi {
  pois: Poi[]
  [x: string]: any
}

export type GetNearByInfos = (location: Location | Poi) => Promise<AmapNearByPoiInfo>

interface Options {
  defaultPoi?: Poi // \u6307\u5B9A\u9ED8\u8BA4poi \u683C\u5F0F\u4E3A\u9AD8\u5FB7\u5730\u56FEPoi\u683C\u5F0F
  currentLocation?: { city?: string; [x: string]: any } // \u5F53\u524D\u5B9A\u4F4D\u4FE1\u606F\uFF0C\u901A\u5E38\u65E0\u9700\u4F20\u8FD9\u4E2A\u503C\uFF0CsearchPois\u65F6\u5982\u4E0D\u4F20city\uFF0C\u5219\u4F7F\u7528\u6B64\u5904\u5F53\u524D\u5B9A\u4F4D\u7684\u57CE\u5E02
  services?: {
    getNearByPoiList?: GetNearByInfos // \u81EA\u884C\u5C01\u88C5\u7684\u83B7\u53D6\u9644\u8FD1\u7684poi\u5217\u8868\u7684\u670D\u52A1\uFF0C\u4F7F\u7528\u83B7\u53D6\u9644\u8FD1Poi\u529F\u80FD\u5FC5\u4F20\u3002
    searchPoiList?: any // \u81EA\u884C\u5C01\u88C5\u7684\u641C\u7D22poi\u7684\u670D\u52A1\uFF0C\u4F7F\u7528\u641C\u7D22poi\u529F\u80FD\u5FC5\u4F20
  }
  onCurrentPoiChange?: (poi: Poi) => void
  formatPoi?: (poi: Poi) => Poi

  amapKey?: string
}

type GetNearbyPois = (options?: {
  current: Location
  size?: number // \u5C55\u793A\u6570\u91CF
  formatPois?: ((pois: Poi[]) => Poi[]) | ((pois: Poi[]) => Promise<Poi[]>)
  showCurrent?: boolean
}) => Promise<Poi[]>

interface UseAmapPoiRetrun {
  currentPoi: Poi
  pois: any[]
  nearbyPois: any[]
  onSelectPoi: (poi: Poi) => Promise<void>
  getNearbyPois: GetNearbyPois
  searchPois: (params: any) => Promise<Poi[]>
  setCurrentPos: (current: Poi) => Promise<Poi>
}

/**
 * \u83B7\u53D6\u9AD8\u5FB7\u5730\u56FEpoi\uFF0C\u4E3B\u8981\u7528\u4E8E\u4E34\u65F6\u7684poi\uFF0C\u5982\u521B\u5EFA\u5730\u5740\u65F6\u9009\u62E9poi\u3002\u5305\u542B\u67E5\u8BE2\u5C55\u793Apoi\u5217\u8868\uFF0C\u9009\u4E2Dpoi\u76F8\u5173\u903B\u8F91
 * @returns
 */
export default function useAmapPoi({
  defaultPoi,
  currentLocation,
  services: { getNearByPoiList, searchPoiList } = {},
  onCurrentPoiChange,
  formatPoi = formatPoiInfo,
  amapKey,
}: Options = {}): UseAmapPoiRetrun {
  const loadedScriptRef = useRef<boolean>(false)
  if (isBrowser) {
    // \u5982\u679C\u662F\u6D4F\u89C8\u5668\u7AEF\u4F7F\u7528\uFF0C\u9ED8\u8BA4\u53EF\u4EE5\u4E0D\u4F20service\u800C\u4F7F\u7528\u5185\u7F6E\u7684
    getNearByPoiList = getNearByPoiList || getNearByInfos
    searchPoiList = searchPoiList || searchPois
    if (!loadedScriptRef.current && amapKey) {
      loadedScriptRef.current = true
      loadAmapScript(amapKey)
    }
  }

  const [currentPoi, setCurrentPoi] = useState(defaultPoi)
  const [pois, setPois] = useState([])
  const [nearbyPois, setNearbyPois] = useState([])

  const handleSetCurrentPos = async (poi: Location | Poi) => {
    if (!poi.latitude || !poi.longitude) {
      setCurrentPoi({})
      return
    }

    let newPoiData = await formatPoi(poi)
    if ((!newPoiData.city || !newPoiData.poiId) && getNearByPoiList) {
      const data = await getNearByPoiList(poi)
      newPoiData.city =
        newPoiData.city || data.city || data.cityname || data.pois?.[0]?.city || data.pois?.[0]?.cityname
      newPoiData.poiId = newPoiData.poiId || data.poiId || data.pois?.[0]?.poiId
      newPoiData = await formatPoi(newPoiData)
    }
    if (!newPoiData.city) return
    setCurrentPoi(newPoiData)
    return newPoiData
  }

  // \u8BBE\u7F6E\u4E34\u65F6\u7684\u5730\u5740\u9009\u62E9
  const onSelectPoi = async (poi: Poi) => {
    let newPoiData
    try {
      newPoiData = await handleSetCurrentPos(poi)
      onCurrentPoiChange && onCurrentPoiChange(newPoiData)
    } catch (error) {
      console.log('select poi error')
    }
  }

  // \u6839\u636E\u57CE\u5E02/\u641C\u7D22\u5173\u952E\u5B57\u83B7\u53D6\u5730\u5740\u5217\u8868\uFF0C \u5982\u4E0D\u4F20city\uFF0C\u5219\u4F7F\u7528\u5F53\u524D\u5B9A\u4F4D\u7684\u57CE\u5E02
  const handleSearchPois = async (params) => {
    if (!searchPoiList) {
      throw new Error('please set service searchPoiList')
    }
    try {
      const resultPois = (await searchPoiList({ ...params, city: params.city || currentLocation?.city })) || []
      setPois(resultPois)
      return resultPois
    } catch (error) {
      console.log(error)
    }
  }

  /**
   * \u6839\u636E\u5B9A\u4F4D\u83B7\u53D6\u51E0\u6761\u9644\u8FD1\u7684Poi
   */
  const getNearbyPois: GetNearbyPois = async ({
    current,
    size = 5,
    formatPois = (pois: Poi[]) => pois.map(formatPoi),
    showCurrent = false,
  }) => {
    if (!getNearByPoiList) {
      throw new Error('please set service getNearByPoiList')
    }
    const result = await getNearByPoiList(current)
    const showPois: Poi[] =
      result.pois
        ?.splice(0, size)
        .map((poi: Poi) => ({ ...poi, city: poi.city || current.city || current.cityname })) || []

    if (!result.latitude || !result.longitude || !showPois?.length) {
      setNearbyPois([])
      return []
    }

    // \u5730\u56FE\u7B49\u5F53\u524D\u5B9A\u4F4D\u5217\u8868\u91CC\u589E\u52A0\u5F53\u524D\u5B9A\u4F4D\u70B9
    if (showCurrent) {
      showPois.unshift(current)
    }

    // \u6709\u65F6\u5019\u9700\u8981\u67E5\u8BE2poi\u662F\u5426\u5728\u8303\u56F4\u5185\u7B49\u5904\u7406
    const formatedPois = await formatPois(showPois)
    setNearbyPois(formatedPois)
  }

  return {
    currentPoi,
    pois,
    nearbyPois,
    onSelectPoi,
    setCurrentPos: handleSetCurrentPos,
    getNearbyPois, // \u83B7\u53D6\u9644\u8FD1\u7684poi
    searchPois: handleSearchPois,
  }
}`,x=`export const isBrowser = !!(typeof window !== 'undefined' && window.document && window.document.createElement)

export const isNil = (value: any) => value === undefined || value === null`,D=`import { isBrowser } from '../utils'

export function formatPoiInfo(poi: any) {
  let name = poi.name || poi.formattedAddress
  name = formatPoiName(poi, name)
  const address = poi.formattedAddress + poi.number
  const currentPoi = {
    ...poi,
    latitude: poi.latitude,
    longitude: poi.longitude,
    adcode: poi.adCode,
    name,
    address,
    city: poi.city || poi.cityname,
    cityCode: poi.cityCode,
  }
  return currentPoi
}

export function formatPoiName(data: any, name: string = '') {
  const { province = '', city = '', district = '' } = data
  const removeAddress = province + city + district
  let newName = name.replace(removeAddress, '')

  if (newName.length > 18) {
    if (data.street) {
      newName = newName.replace(data.street, '')
    }
  }

  return newName
}

export const getNearByInfos = ({ latitude, longitude }) => {
  return new Promise<any>((resolve, reject) => {
    if (!isBrowser) {
      return reject(new Error('must be used in web'))
    }
    try {
      const AMap = (window as any).AMap
      const searchNearBy = () => {
        AMap.plugin('AMap.PlaceSearch', function () {
          const poiSearch = new AMap.PlaceSearch({
            pageSize: 5, // \u5355\u9875\u663E\u793A\u7ED3\u679C\u6761\u6570
            pageIndex: 1, // \u9875\u7801
            extensions: 'all',
          })

          poiSearch.searchNearBy('', [longitude, latitude], 200, (status: string, result: any) => {
            if (status === 'complete' && result.info === 'OK') {
              const { poiList = {} } = result
              poiList.pois = (poiList.pois || []).map((poi) => {
                const { lat, lng } = poi.location
                return Object.assign(poi, { longitude: lng, latitude: lat, city: poi.cityname })
              })

              resolve(Object.assign(poiList, { longitude, latitude }))
            } else {
              reject(new Error('get nearby pois fail'))
            }
          })
        })
      }
      searchNearBy()
    } catch (error) {
      reject(new Error('get nearby pois fail'))
    }
  })
}

export const searchPois = ({ city, address }: { city?: string; address?: string } = {}) => {
  return new Promise((resolve, reject) => {
    const AMap = (window as any)?.AMap

    AMap.plugin('AMap.PlaceSearch', function () {
      const placeSearch = new AMap.PlaceSearch({
        city,
      })
      placeSearch.search(address, function (status, result) {
        // \u67E5\u8BE2\u6210\u529F\u65F6\uFF0Cresult\u5373\u5BF9\u5E94\u5339\u914D\u7684POI\u4FE1\u606F
        if (status === 'complete' && result.info === 'OK') {
          const { poiList = {} } = result
          poiList.pois = (poiList.pois || []).map((poi) => {
            const { lat, lng } = poi.location
            return Object.assign(poi, { longitude: lng, latitude: lat, city: poi.cityname })
          })

          resolve(poiList.pois)
        } else {
          // reject(new Error('get nearby pois fail'))
        }
      })
    })
  })
}

const inserScript = (src) => {
  return new Promise((resolve, reject) => {
    const attr = {
      name: 'amap',
      src,
      type: 'text/javascript',
    }

    const parent = document.querySelector('body') // \u5BB9\u5668
    let script = parent && parent.querySelector(\`[name=\${attr.name}]\`)
    if (script) {
      resolve(true)
    } else {
      script = document.createElement('script')
      Object.getOwnPropertyNames(attr).forEach((name) => {
        script.setAttribute(name, attr[name]) // \u6682\u65F6\u53EA\u652F\u6301\u4E00\u5C42object
      })
      parent.appendChild(script).addEventListener(
        'load',
        () => {
          resolve(true)
        },
        false,
      )
    }
  })
}

export const loadAmapScript = (amapKey?: string, plugin = 'AMap.Geocoder') => {
  return new Promise((resolve, reject) => {
    if (!isBrowser) {
      return reject(new Error('must be used in browser'))
    }
    const AMap = (window as any)?.AMap
    if (!AMap) {
      if (amapKey) {
        inserScript(\`//webapi.amap.com/maps?v=2.0&key=\${amapKey}&plugin=\${plugin}\`).then(resolve)
      } else {
        // eslint-disable-next-line no-console
        console.error('please use setAmapKey to set key')
      }
    } else if (AMap && !AMap.Map) {
      // eslint-disable-next-line no-console
      console.error('please use plugin AMap.Geocoder')
    } else if (AMap && AMap.Map) {
      // fn(...args)
      resolve(true)
    }
  })
}`,k={"usecountdown-demo":{component:(0,u.D8)({loader:function(){var n=(0,a.Z)(s().mark(function i(){return s().wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,t.e(6050).then(t.bind(t,22380));case 2:return e.abrupt("return",e.sent.default);case 3:case"end":return e.stop()}},i)}));function o(){return n.apply(this,arguments)}return o}(),loading:()=>null}),previewerProps:{sources:{_:{tsx:g},"index.ts":{import:".",content:v},"utils/index.ts":{import:"../utils",content:m}},dependencies:{react:{version:"16.14.0"}},identifier:"usecountdown-demo"}},"usecountup-demo":{component:(0,u.D8)({loader:function(){var n=(0,a.Z)(s().mark(function i(){return s().wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,t.e(6050).then(t.bind(t,60315));case 2:return e.abrupt("return",e.sent.default);case 3:case"end":return e.stop()}},i)}));function o(){return n.apply(this,arguments)}return o}(),loading:()=>null}),previewerProps:{sources:{_:{tsx:w},"index.ts":{import:".",content:S},"useForceRender/index.ts":{import:"../useForceRender",content:d},"utils/index.ts":{import:"../utils",content:m}},dependencies:{react:{version:"16.14.0"}},identifier:"usecountup-demo"}},"usehistoryref-demo":{component:(0,u.D8)({loader:function(){var n=(0,a.Z)(s().mark(function i(){return s().wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,t.e(6050).then(t.bind(t,19353));case 2:return e.abrupt("return",e.sent.default);case 3:case"end":return e.stop()}},i)}));function o(){return n.apply(this,arguments)}return o}(),loading:()=>null}),previewerProps:{sources:{_:{tsx:b},"useCounter/index.ts":{import:"../useCounter",content:P},"index.ts":{import:".",content:R},"historyState.ts":{import:"./historyState",content:C},"useForceRender/index.ts":{import:"../useForceRender",content:d}},dependencies:{react:{version:"16.14.0"}},identifier:"usehistoryref-demo"}},"useamappoi-demo":{component:(0,u.D8)({loader:function(){var n=(0,a.Z)(s().mark(function i(){return s().wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,t.e(6050).then(t.bind(t,45331));case 2:return e.abrupt("return",e.sent.default);case 3:case"end":return e.stop()}},i)}));function o(){return n.apply(this,arguments)}return o}(),loading:()=>null}),previewerProps:{sources:{_:{tsx:T},"index.ts":{import:".",content:L},"utils/index.ts":{import:"../utils",content:x},"helper.ts":{import:"./helper",content:D}},dependencies:{react:{version:"16.14.0"}},identifier:"useamappoi-demo"}}},A={},M=t(56500),U=n=>p.createElement(M.Z,(0,l.Z)({},n,{config:f,demos:k,apis:A}))}}]);
